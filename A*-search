

import heapq

GOAL_STATE = [[1, 2, 3],
              [8, 0, 4],
              [7, 6, 5]]

DIRS = [(-1, 0, 'up'), (1, 0, 'down'), (0, -1, 'left'), (0, 1, 'right')]


def board_to_tuple(board):
    return tuple(tile for row in board for tile in row)


def misplaced_tiles(state, goal):
    return sum(1 for i in range(3) for j in range(3)
               if state[i][j] != 0 and state[i][j] != goal[i][j])


def manhattan_distance(state, goal):
    goal_pos = {goal[i][j]: (i, j) for i in range(3) for j in range(3)}
    distance = 0
    for i in range(3):
        for j in range(3):
            tile = state[i][j]
            if tile != 0:
                goal_i, goal_j = goal_pos[tile]
                distance += abs(i - goal_i) + abs(j - goal_j)
    return distance


def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j


def get_neighbors(state):
    neighbors = []
    x, y = find_blank(state)
    for dx, dy, move in DIRS:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [row[:] for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append((new_state, move))
    return neighbors


def reconstruct_path(came_from, moves_from, current):
    if board_to_tuple(current) not in came_from:
        return ["start"]
    else:
        prev = came_from[board_to_tuple(current)]
        move = moves_from[board_to_tuple(current)]
        return reconstruct_path(came_from, moves_from, prev) + [move]


def print_board(state):
    for row in state:
        print(' '.join(str(tile) if tile != 0 else ' ' for tile in row))
    print()


def a_star(start, heuristic='manhattan'):
    goal = GOAL_STATE
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    moves_from = {}
    g_score = {board_to_tuple(start): 0}
    iteration = 0

    while open_set:
        _, current = heapq.heappop(open_set)
        iteration += 1

        # Find the move that got us here, or "start" if beginning
        current_tuple = board_to_tuple(current)
        move = moves_from[current_tuple] if current_tuple in moves_from else "start"

        print(f"Iteration {iteration}: move = {move}")
        print_board(current)

        if current == goal:
            return reconstruct_path(came_from, moves_from, current), current

        for neighbor, move in get_neighbors(current):
            tentative_g = g_score[board_to_tuple(current)] + 1
            neighbor_tuple = board_to_tuple(neighbor)

            if neighbor_tuple not in g_score or tentative_g < g_score[neighbor_tuple]:
                came_from[neighbor_tuple] = current
                moves_from[neighbor_tuple] = move
                g_score[neighbor_tuple] = tentative_g

                if heuristic == 'manhattan':
                    h = manhattan_distance(neighbor, goal)
                elif heuristic == 'misplaced':
                    h = misplaced_tiles(neighbor, goal)
                else:
                    raise ValueError("Invalid heuristic.")

                f = tentative_g + h
                heapq.heappush(open_set, (f, neighbor))

    return None, None  # No solution


def get_user_input():
    print("Enter the puzzle (use 0 for the blank space).")
    puzzle = []
    entries = set()
    for i in range(1, 4):
        while True:
            try:
                row_input = input(f"Row {i} (e.g. 1 2 3): ")
                row = list(map(int, row_input.strip().split()))
                if len(row) != 3 or any(n < 0 or n > 8 for n in row):
                    raise ValueError
                entries.update(row)
                puzzle.append(row)
                break
            except ValueError:
                print("Invalid row. Please enter exactly 3 numbers between 0 and 8.")
    if entries != set(range(9)):
        raise ValueError("Invalid puzzle: Must contain all numbers from 0 to 8 without duplicates.")
    return puzzle


if __name__ == "__main__":
    try:
        start_state = get_user_input()
        heuristic = input("Choose heuristic ('manhattan' or 'misplaced'): ").strip().lower()
        if heuristic not in ['manhattan', 'misplaced']:
            raise ValueError("Invalid heuristic. Choose 'manhattan' or 'misplaced'.")

        print(f"\nSolving 8-puzzle using {heuristic} heuristic...\n")
        move_path, final_state = a_star(start_state, heuristic=heuristic)

        if move_path:
            move_path.append("end")
            print("Moves:", ', '.join(move_path))
            print(f"\nSolution found in {len(move_path) - 2} moves:\n")  # excluding start and end
            print_board(final_state)
        else:
            print("No solution found.")
    except Exception as e:
        print(f"Error: {e}")

