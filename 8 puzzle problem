
import copy

# Define the goal state (solved puzzle)
goal_state = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

# Possible moves for the blank tile: up, down, left, right
moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def find_blank(state):
    """Locate the blank tile (0) position in the state."""
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def is_goal(state):
    """Check if the state matches the goal state."""
    return state == goal_state

def copy_state(state):
    """Return a deep copy of the puzzle state."""
    return copy.deepcopy(state)

def state_to_tuple(state):
    """Convert 2D list state to a tuple of tuples to store in sets."""
    return tuple(tuple(row) for row in state)

def dls(state, depth_limit, visited, path):
    """Depth-Limited Search with cycle detection."""
    if is_goal(state):
        print("Goal state reached!")
        for step in path:
            for row in step:
                print(row)
            print("---")
        return True
   
    if depth_limit == 0:
        return False
   
    blank_row, blank_col = find_blank(state)
   
    for move in moves:
        new_row = blank_row + move[0]
        new_col = blank_col + move[1]
       
        # Check if move is within bounds
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            next_state = copy_state(state)
           
            # Swap blank with adjacent tile
            next_state[blank_row][blank_col], next_state[new_row][new_col] = next_state[new_row][new_col], next_state[blank_row][blank_col]
           
            next_state_tuple = state_to_tuple(next_state)
           
            if next_state_tuple not in visited:
                visited.add(next_state_tuple)
                if dls(next_state, depth_limit - 1, visited, path + [next_state]):
                    return True
                visited.remove(next_state_tuple)
    return False

def ids(initial_state, max_depth=20):
    """Iterative Deepening Search."""
    initial_state_tuple = state_to_tuple(initial_state)
   
    for depth in range(max_depth + 1):
        print(f"Searching with depth limit: {depth}")
        visited = set()
        visited.add(initial_state_tuple)
        if dls(initial_state, depth, visited, [initial_state]):
            print(f"Solved at depth {depth}!")
            return True
    print("Failed to find solution within max depth.")
    return False

def get_user_input():
    print("Enter the initial puzzle state row by row (use 0 for the blank tile):")
    state = []
    for i in range(3):
        while True:
            row = input(f"Row {i+1} (3 numbers separated by spaces): ").strip().split()
            if len(row) != 3:
                print("Please enter exactly 3 numbers.")
                continue
            try:
                row_nums = [int(x) for x in row]
            except ValueError:
                print("Please enter valid integers.")
                continue
            if any(num < 0 or num > 8 for num in row_nums):
                print("Numbers must be between 0 and 8.")
                continue
            if len(set(row_nums)) != 3:
                # Just warn, but duplicates are possible if user enters invalid puzzle, no full validation here.
                pass
            state.append(row_nums)
            break
    return state

if __name__ == "__main__":
    initial_state = get_user_input()
    ids(initial_state, max_depth=20)


